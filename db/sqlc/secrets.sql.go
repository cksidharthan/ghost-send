// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: secrets.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const checkSecretStatus = `-- name: CheckSecretStatus :one
SELECT EXISTS (
    SELECT 1 FROM secrets 
    WHERE id = $1::uuid 
    AND expires_at > CURRENT_TIMESTAMP
    AND remaining_tries > 0
) as exists
`

// Checks if a secret exists and is still accessible
// Args: $1: secret UUID
func (q *Queries) CheckSecretStatus(ctx context.Context, secretID uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkSecretStatus, secretID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createSecret = `-- name: CreateSecret :one
INSERT INTO secrets (
    secret_text,
    password_hash,
    salt,
    expires_at,
    remaining_tries
) VALUES (
    pgp_sym_encrypt($1, $2)::text,
    crypt($2, gen_salt('bf'))::text,
    gen_salt('bf'),
    $3,
    $4
) RETURNING id, secret_text, password_hash, salt, expires_at, created_at, remaining_tries, last_viewed_at
`

type CreateSecretParams struct {
	SecretText     string    `json:"secret_text"`
	Password       string    `json:"password"`
	ExpiresAt      time.Time `json:"expires_at"`
	RemainingTries int32     `json:"remaining_tries"`
}

// Creates a new secret with encrypted text and password protection
// Args:
//
//	$1: secret text to encrypt
//	$2: password for encryption and access
//	$3: expiration timestamp
//	$4: number of allowed tries
func (q *Queries) CreateSecret(ctx context.Context, arg CreateSecretParams) (Secret, error) {
	row := q.db.QueryRowContext(ctx, createSecret,
		arg.SecretText,
		arg.Password,
		arg.ExpiresAt,
		arg.RemainingTries,
	)
	var i Secret
	err := row.Scan(
		&i.ID,
		&i.SecretText,
		&i.PasswordHash,
		&i.Salt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.RemainingTries,
		&i.LastViewedAt,
	)
	return i, err
}

const decrementTries = `-- name: DecrementTries :one
UPDATE secrets
SET remaining_tries = remaining_tries - 1,
    last_viewed_at = CASE 
        WHEN remaining_tries <= 1 THEN CURRENT_TIMESTAMP 
        ELSE last_viewed_at 
    END
WHERE id = $1::uuid
RETURNING id, secret_text, password_hash, salt, expires_at, created_at, remaining_tries, last_viewed_at
`

// Decrements remaining tries and auto-deletes if no tries remain
// Args: $1: secret UUID
func (q *Queries) DecrementTries(ctx context.Context, secretID uuid.UUID) (Secret, error) {
	row := q.db.QueryRowContext(ctx, decrementTries, secretID)
	var i Secret
	err := row.Scan(
		&i.ID,
		&i.SecretText,
		&i.PasswordHash,
		&i.Salt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.RemainingTries,
		&i.LastViewedAt,
	)
	return i, err
}

const deleteExpiredSecrets = `-- name: DeleteExpiredSecrets :exec
DELETE FROM secrets
WHERE expires_at <= CURRENT_TIMESTAMP
`

// Deletes all expired secrets
func (q *Queries) DeleteExpiredSecrets(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredSecrets)
	return err
}

const deleteSecret = `-- name: DeleteSecret :exec
DELETE FROM secrets
WHERE id = $1::uuid
`

// Soft deletes a secret by UUID
// Args: secret_id: secret UUID
func (q *Queries) DeleteSecret(ctx context.Context, secretID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteSecret, secretID)
	return err
}

const getSecretByID = `-- name: GetSecretByID :one
WITH secret_data AS (
    SELECT 
        s.id, s.secret_text, s.password_hash, s.salt, s.expires_at, s.created_at, s.remaining_tries, s.last_viewed_at,
        (s.password_hash = crypt($1, s.password_hash)) as password_matches,
        CASE 
            WHEN remaining_tries <= 1 THEN TRUE
            ELSE FALSE
        END as should_delete
    FROM secrets s
    WHERE id = $2::uuid 
    AND expires_at > CURRENT_TIMESTAMP
)
SELECT 
    id,
    CASE 
        WHEN password_matches THEN pgp_sym_decrypt(secret_text::bytea, $1)::text 
        ELSE NULL 
    END::text as secret_text,
    password_hash,
    salt,
    expires_at,
    created_at,
    remaining_tries,
    last_viewed_at,
    password_matches,
    should_delete
FROM secret_data
`

type GetSecretByIDParams struct {
	Password string    `json:"password"`
	SecretID uuid.UUID `json:"secret_id"`
}

type GetSecretByIDRow struct {
	ID              uuid.UUID    `json:"id"`
	SecretText      string       `json:"secret_text"`
	PasswordHash    string       `json:"password_hash"`
	Salt            string       `json:"salt"`
	ExpiresAt       time.Time    `json:"expires_at"`
	CreatedAt       sql.NullTime `json:"created_at"`
	RemainingTries  int32        `json:"remaining_tries"`
	LastViewedAt    sql.NullTime `json:"last_viewed_at"`
	PasswordMatches bool         `json:"password_matches"`
	ShouldDelete    bool         `json:"should_delete"`
}

func (q *Queries) GetSecretByID(ctx context.Context, arg GetSecretByIDParams) (GetSecretByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getSecretByID, arg.Password, arg.SecretID)
	var i GetSecretByIDRow
	err := row.Scan(
		&i.ID,
		&i.SecretText,
		&i.PasswordHash,
		&i.Salt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.RemainingTries,
		&i.LastViewedAt,
		&i.PasswordMatches,
		&i.ShouldDelete,
	)
	return i, err
}

const getSecretStats = `-- name: GetSecretStats :one
SELECT 
    COUNT(*) FILTER (WHERE remaining_tries > 0) as active_secrets,
    COUNT(*) FILTER (WHERE last_viewed_at IS NOT NULL) as viewed_secrets,
    COUNT(*) FILTER (WHERE remaining_tries = 0) as failed_attempts
FROM secrets
`

type GetSecretStatsRow struct {
	ActiveSecrets  int64 `json:"active_secrets"`
	ViewedSecrets  int64 `json:"viewed_secrets"`
	FailedAttempts int64 `json:"failed_attempts"`
}

// Returns statistics about secrets in the system:
// - Number of active (non-deleted) secrets
// - Number of viewed secrets
// - Number of secrets that failed due to too many attempts
func (q *Queries) GetSecretStats(ctx context.Context) (GetSecretStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getSecretStats)
	var i GetSecretStatsRow
	err := row.Scan(&i.ActiveSecrets, &i.ViewedSecrets, &i.FailedAttempts)
	return i, err
}

const markSecretViewed = `-- name: MarkSecretViewed :one
UPDATE secrets
SET last_viewed_at = CURRENT_TIMESTAMP,
    remaining_tries = 0
WHERE id = $1::uuid
RETURNING id, secret_text, password_hash, salt, expires_at, created_at, remaining_tries, last_viewed_at
`

// Marks a secret as viewed and deletes it (one-time view)
// Args: $1: secret UUID
func (q *Queries) MarkSecretViewed(ctx context.Context, secretID uuid.UUID) (Secret, error) {
	row := q.db.QueryRowContext(ctx, markSecretViewed, secretID)
	var i Secret
	err := row.Scan(
		&i.ID,
		&i.SecretText,
		&i.PasswordHash,
		&i.Salt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.RemainingTries,
		&i.LastViewedAt,
	)
	return i, err
}
